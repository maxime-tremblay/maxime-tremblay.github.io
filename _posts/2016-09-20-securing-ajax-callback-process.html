---
layout: post
title: Securing Ajax Callback Process
date: '2016-09-20T15:28:00.001-04:00'
author: Maxime Tremblay
tags:
- Secure
- Ajax
- APEX5
modified_time: '2017-02-02T20:58:46.176-05:00'
thumbnail: https://2.bp.blogspot.com/-0LLh5Thhf6o/V-Ls04N_pII/AAAAAAAAAOk/crYvzKRDdyEq2tNMztz1cPovbJyOhtmIACLcB/s72-c/arguments-checksum.png
blogger_id: tag:blogger.com,1999:blog-267713902572011003.post-3231813867743810967
blogger_orig_url: https://max-tremblay.blogspot.com/2016/09/securing-ajax-callback-process.html
---

When navigating from a report page to the corresponding detail page, it's always a good practice to enable the parameters checksum to prevent users from tampering with the item values that are in the url.<br /><br />To enable arguments checksum, you must first set the "Page Access Protection" attribute under the page attribute security section to "Arguments must have checksum" and then for each item that is going to be assigned from the url, you need to set the "Session State Protection" to one of the "Checksum Required" value (have a look at the item's help for more details about the different types of checksum).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-0LLh5Thhf6o/V-Ls04N_pII/AAAAAAAAAOk/crYvzKRDdyEq2tNMztz1cPovbJyOhtmIACLcB/s1600/arguments-checksum.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="292" src="https://2.bp.blogspot.com/-0LLh5Thhf6o/V-Ls04N_pII/AAAAAAAAAOk/crYvzKRDdyEq2tNMztz1cPovbJyOhtmIACLcB/s400/arguments-checksum.png" width="400" /></a></div><br /><br />That way the user is not going to be able to change any value from the url.<br /><br />I recently had to implement a similar concept using button in a report that were calling an AJAX Callback Process from a dynamic action.<br /><br />Here's what my report's SQL Query looked like:<br /><blockquote class="tr_bq"><pre class="line-numbers"><code class="language-sql">select '&lt;button onclick="void(0);"'<br />           || ' data-data1="' || some_table_id || '"'<br />           || ' data-data2="' || some_value || '"'<br />           --|| ' data-data3="' || sys.dbms_crypto.hash(utl_raw.cast_to_raw(some_table_id || some_value || to_char(nvl(last_update_date, creation_date), :DATETIMEFORMAT)), 3) || '"' /* Where 3 -&gt; SHA-1 from sys.dbms_crypto.hash_sh1 */<br />           || ' data-data3="' || apex_util.get_hash(apex_t_varchar2(some_table_id, some_value, to_char(nvl(last_update_date, creation_date), :DATETIMEFORMAT))) || '"'<br />           || ' class="t-Button t-Button--hot t-Button--small actionButton"'<br />           || ' type="button"&gt;&lt;span class="t-Button-label"&gt;Some Action&lt;/span&gt;&lt;/button&gt;'<br />       /* Rest of the query */<br />  from some_table<br /> where /* where clauses */<br /></code></pre></blockquote>Where data1 and data2 are the values that are needed in the AJAX Callback Process and data3 is the checksum for the previous values.<br />To have a stronger checksum and to ensure that it is only used once, I added the record's last update date to it.<br />DATETIMEFORMAT is an application substitution string.<br /><br />Note: in order to be able to use dbms_crypto, it needs to be granted to the current user (not required with the apex_util.get_hash function.<br />For more information on the Apex API, read this&nbsp;<a href="http://docs.oracle.com/cd/E59726_01/doc.50/e39149/apex_util.htm#AEAPI30207" target="_blank">GET_HASH Function</a>.<br /><br />The corresponding dynamic action to handle the button click was as follow:<br /><blockquote class="tr_bq">Dynamic Action: Event: Click<br />jQuery Selector: ".actionButton"<br /><pre class="line-numbers"><code class="language-javascript">var lSpinner$ = apex.util.showSpinner();<br />var lReportRegion$ = $(this.affectedElements);<br /><br />apex.server.process("AJAX_PROCESS_NAME",<br />                    {x01: $(this.triggeringElement).data('data1'),<br />                     x02: $(this.triggeringElement).data('data2'),<br />                     x03: $(this.triggeringElement).data('data3')<br />                     },<br />                    {success: function( pData ) {<br />                        if (pData.success === true){<br />                            /* Show Sucess Message */<br />                            showSuccessMessage(pData.message);<br />                            <br />                            /* Refresh Region */<br />                            lReportRegion$.trigger('apexrefresh');<br />                        }<br />                        else{<br />                            /* Show Error Message */<br />                            showErrorMessage([pData.message]);<br />                        }<br />                        <br />                        lSpinner$.remove();<br />                      }<br />                     }<br />                    );<br /></code></pre></blockquote>In the previous code, I'm using the affected element attribute to refresh my report region.<br /><br />Here's the AJAX Callback Process:<br /><blockquote class="tr_bq"><pre class="line-numbers"><code class="language-sql">declare<br />    l_some_table_id number;<br />    l_some_value    varchar2(50);<br />    l_checksum      varchar2(32767);<br />    --l_checksum      raw(32767); --sys.dbms_crypto.hash returns raw<br />    --l_hash_type     pls_integer := sys.dbms_crypto.hash_sh1;<br />    <br />    l_last_update   varchar2(100);<br />begin<br />    /* Retrieve parameters */<br />    l_some_table_id := to_number(apex_application.g_x01);<br />    l_some_value    := apex_application.g_x02;<br />    l_checksum      := apex_application.g_x03;<br />    <br />    select to_char(nvl(last_update_date, creation_date), :DATETIMEFORMAT)<br />      into l_last_update<br />      from some_table<br />     where some_table_id = l_some_table_id;<br />    <br />    /* Validate the checksum */<br />    --if l_checksum = sys.dbms_crypto.hash(utl_raw.cast_to_raw(l_some_table_id || l_some_value || l_last_update), l_hash_type) then<br />    if l_checksum = apex_util.get_hash(apex_t_varchar2(l_some_table_id, l_some_value, l_last_update)) then<br />        /* Do something */<br />        <br />        apex_json.open_object;<br />        apex_json.write('success', true);<br />        apex_json.write('message', 'Action Processed.');<br />        apex_json.close_object;<br />    else<br />        apex_json.open_object;<br />        apex_json.write('success', false);<br />        apex_json.write('message', 'Invalid Action.');<br />        apex_json.close_object;<br />    end if;<br />exception<br />    when no_data_found then<br />        apex_json.open_object;<br />        apex_json.write('success', false);<br />        apex_json.write('message', 'Invalid Action.');<br />        apex_json.close_object;<br />    when others then<br />        apex_json.open_object;<br />        apex_json.write('success', false);<br />        apex_json.write('message', 'Invalid Action.');<br />        apex_json.close_object;<br />end;<br /></code></pre></blockquote><br /><br />Basically what we do in the process is to recreate a checksum based on the parameters' values and to compare it with the checksum parameter and if they match we execute the code that needs to run. <br /><br />Note: Edited above code to use the Apex API: apex_util.get_hash. Commented out everything related to dbms_crypto for reference purpose.